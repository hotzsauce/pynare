
import pynare.parsing.ast as ast

from pynare.parsing.tokens import Token
from pynare.parsing.generic import (
	ABCParser,
	ABCVisitor
)

from pynare.parsing.base import (
	# number, variable name, parentheses
	NUMBER,
	ID,
	LPARE,
	RPARE,
	# mathematical operations
	PLUS,
	MINUS,
	MUL,
	DIV,
	POWER
)


class Parser(ABCParser):
	""" 
	Parses algebraic expressions with numbers, variables, addition, subtraction, 
	multiplication, division, and exponentiation. Supports parsing of arbitrary 
	parenthetically-nested expressions
	"""
	
	def __init__(self, lexer):
		super().__init__(lexer)


	def atom(self):
		"""
		atom : ID
			 | NUMBER
			 | LPARE expr RPARE
			 | (MINUS | PLUS) term
		"""
		token = self.current_token

		if token.type == ID:
			node = ast.Var(token)
			self.eat(ID)
			return node
		elif token.type == NUMBER:
			self.eat(NUMBER)
			return ast.Num(token)
		elif token.type == LPARE:
			self.eat(LPARE)
			node = self.expr()
			self.eat(RPARE)
			return node
		elif token.type in (MINUS, PLUS):
			self.eat(token.type)
			# sending the 'expr' to term() instead of expr() is what ensures
			# 	the unary operation functionality
			node = ast.UnaryOp(op=token,
								expr=self.term())
			return node

		self.error()

	def exponent(self):
		"""
		exponent : atom (POWER exponent)*
		"""
		node = self.atom()

		while self.current_token.type == POWER:
			token = self.current_token
			self.eat(POWER)

			# sending the 'right' attribute to exponent() instead of down to atom()
			# 	like other binary operations is what ensures exponentiation to 
			#	be right-associative
			node = ast.BinaryOp(left=node,
								op=token,
								right=self.exponent())
		return node

	def term(self):
		"""
		term : exponent ((MUL | DIV) exponent)*
		"""
		node = self.exponent()

		while self.current_token.type in (MUL, DIV):
			token = self.current_token
			self.eat(token.type)

			node = ast.BinaryOp(left=node,
								op=token,
								right=self.exponent())
		return node

	def expr(self):
		"""
		expr : term ((PLUS | MINUS) term)*
		"""
		node = self.term()

		while self.current_token.type in (PLUS, MINUS):
			token = self.current_token
			self.eat(token.type)

			node = ast.BinaryOp(left=node,
								op=token,
								right=self.term())
		return node

	def parse(self):
		return self.expr()


class Interpreter(ABCVisitor):
	"""
	Interprets an Abstract Syntax Tree with nodes & leaves only generated by 
	the Parser in this module. For the moment, _GLOBAL_SCOPE is just a dictionary.

	This can interpret mathematical expressions with +, -, *, /, ^ operators and 
	numbers. Encountering Var nodes of an AST is handled via the visit_Var method,
	but because the values of those variables are assigned elsewhere in a .mod 
	file, a NameError will be thrown by this interpreter if you try to evaluate 
	a simple mathematical expression with variables
	"""

	def visit_BinaryOp(self, node):
		if node.op.type == PLUS:
			return self.visit(node.left) + self.visit(node.right)
		elif node.op.type == MINUS:
			return self.visit(node.left) - self.visit(node.right)
		elif node.op.type == MUL:
			return self.visit(node.left) * self.visit(node.right)
		elif node.op.type == DIV:
			return self.visit(node.left) / self.visit(node.right)
		elif node.op.type == POWER:
			return self.visit(node.left) ** self.visit(node.right)

	def visit_UnaryOp(self, node):
		if node.op.type == PLUS:
			return + self.visit(node.expr)
		elif node.op.type == MINUS:
			return - self.visit(node.expr)

	def visit_Num(self, node):
		return node.value

	def visit_Var(self, node):
		var_name = node.value
		var_value = self._GLOBAL_SCOPE.get(var_name)
		if var_value is None:
			raise NameError(repr(var_name))
		else:
			return var_value

	def interpret(self):
		return self.visit(self.tree)




























