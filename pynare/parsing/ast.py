""" 
module containing all the nodes and leaves of the Abstract Syntax Tree 
generated by the pynare Parser
"""

class AST(object):
	""" Abstract Base Class for all nodes and leaves in AST """

	def __init__(self):
		pass

	def describe(self, level=0):

		indent = '    '

		# gets all the non-private attributes of the subclass into a list
		valid_attr = lambda d: (not d.startswith('_')) and (d != 'describe') 
		attrs = [d for d in dir(self) if valid_attr(d)]

		# only prints the current AST object name when it's the first level
		if level == 0:
			print('{} with Attributes: '.format(self.__repr__()))
		
		# now we print the AST object's attributes
		for a in attrs:
			attr = getattr(self, a)
			supr = type(self).__bases__ # references the AST class

			print('{indent}{attr_name}: {attr_value}'.format(
					indent=indent*(level+1),
					attr_name=a,
					attr_value=attr)
			)

			if isinstance(attr, supr):
				attr.describe(level=level+1)

			"""
			if hasattr(attr, 'children'):
				# if the attr is a Compound node
				for child in attr.children:
					print(child)
					child.describe(level=level+2)
			"""

			# I think this replaces the commented-out block above
			if a == 'children':
				for child in attr:
					child.describe(level=level+1)
					print(' ')


	def __repr__(self):
		return '<{class_name} Object>'.format(class_name=type(self).__name__)


def _is_iterable_of_ast(obj):
	# returns True if obj is an iterable with all elements instances of AST
	try:
		iter(obj)
		for o in obj:
			if not isinstance(o, AST):
				return False
		return True
	except TypeError:
		return False



# ALGEBRA & FUNCTONAL NODES
class BinaryOp(AST):

	def __init__(self, left, op, right):
		self.left = left
		self.op = op
		self.right = right

class UnaryOp(AST):

	def __init__(self, op, expr):
		self.op = op
		self.expr = expr

class Num(AST):

	def __init__(self, token):
		self.token = token
		self.value = self.token.value

class Function(AST):

	def __init__(self, token, expr):
		self.token = token
		self.value = self.token.value
		self.expr = expr

class Var(AST):

	def __init__(self, token):
		self.token = token
		self.value = self.token.value



# BEFORE MODEL DECLARATION, VARIABLES DECLARED AND VALUES ASSIGNED
class VarDeclaration(AST):

	def __init__(self, var_node, vtype):
		self.var_node = var_node
		self.vtype = vtype

class VarAssignment(AST):

	def __init__(self, left, op, right):
		self.left = left
		self.op = op
		self.right = right



# MODEL DECLARATION NODES
class ModelBlock(AST):

	def __init__(self, parameters, model):
		self.parameters = parameters 
		self.model = model

class Model(AST):

	def __init__(self):
		self.children = list()
 
class ModelExpression(AST):

	def __init__(self, left, right, tag=None):
		self.left = left
		self.right = right
		self.tag = tag

	@property
	def tag(self):
		return self._tag

	@tag.setter
	def tag(self, value):
		self._tag = value

class TagGroup(AST):

	def __init__(self):
		self.children = list()

class Tag(AST):

	def __init__(self, key, value=None):
		self.key = key
		self.value = value

class OffsetVar(AST):

	def __init__(self, var, offset):
		self.var = var
		self.offset = offset

	

# AFTER MODEL DECLARATION, THE INITIAL, TERMINAL, AND HISTORICAL VALUES
#	OF EXOGENOUS AND ENDOGENOUS VARIABLES
class ModelConditionBlock(AST):
	""" setting initial, terminal, and historical values of a model """
	def __init__(self):
		self.initial = None
		self.terminal = None
		self.historical = None

class ModelConditionValues(AST):
	""" 
	handled by Parser in same way as Compount node; only diff is this is 
	initialized with a parameters attribute 
	"""
	def __init__(self, parameters):
		self.parameters = parameters
		self.children = list()



# SHOCKS TO THE MODEL - NOT ENTIRELY SURE HOW THIS WILL BE IMPLEMENTED YET
class ShockBlock(AST):

	def __init__(self):
		self.children = list()

class CorrelatedShock(AST):

	def __init__(self, left, right, expr):
		self.left = left
		self.right = right
		self.expr = expr

class CovaryingShock(AST):

	def __init__(self, left, right, expr):
		self.left = left
		self.right = right
		self.expr = expr

class VarianceShock(AST):

	def __init__(self, token, expr):
		self.token = token
		self.value = self.token.value
		self.expr = expr

class StdErrShock(AST):

	def __init__(self, token, expr):
		self.token = token
		self.value = self.token.value
		self.expr = expr

class DeterministicShock(AST):

	def __init__(self, token, periods, values):
		self.token = token
		self.value = self.token.value
		self.periods = periods
		self.values = values

class ShockPeriod(AST):

	def __init__(self, start, end):
		self.start = start
		self.end = end

class ShockValue(AST):

	def __init__(self, token):
		self.token = token



# STEADY STATE COMMANDS
class SteadyStateBlock(AST):

	def __init__(self):
		self.steady = None
		self.homotopy = None
		self.steady_state_model = None

class SteadyCommand(AST):

	def __init__(self, parameters):
		self.parameters = parameters

class HomotopyBlock(AST):

	def __init__(self):
		self.children = list()

class HomotopyVar(AST):

	def __init__(self, token, start, end):
		self.token = token
		self.start = start
		self.end = end

class SteadyStateModel(AST):

	def __init__(self):
		self.children = list()

class SteadyStateModelExpression(AST):

	def __init__(self, token, expr):
		self.token = token
		self.expr = expr




# MISCELLANEOUS NODES
class Param(AST):

	def __init__(self, token, value=None):
		self.token = token
		self.value = value



class Compound(AST):
	"""
	used whenever a series of ASTs of the same type are grouped together,
	e.g. VarDeclarations, VarAssignments, Params
	"""
	def __init__(self):
		self.children = list()



class ModFile(AST):

	def __init__(self, 
		declaration, 
		assignment, 
		model_block,
		simconditions
	):
		self.declaration = declaration
		self.assignment = assignment
		self.model_block = model_block
		self.simconditions = simconditions