""" 
module containing all the nodes and leaves of the Abstract Syntax Tree 
generated by the pynare Parser
"""

class AST(object):
	""" Abstract Base Class for all nodes and leaves in AST """

	def __init__(self):
		pass

	def describe(self, level=0):

		indent = '    '

		# gets all the non-private attributes of the subclass into a list
		valid_attr = lambda d: (not d.startswith('_')) and (d != 'describe') 
		attrs = [d for d in dir(self) if valid_attr(d)]

		# only prints the current AST object name when it's the first level
		if level == 0:
			print('{} with Attributes: '.format(self.__repr__()))
		
		# now we print the AST object's attributes
		for a in attrs:
			attr = getattr(self, a)
			supr = type(self).__bases__ # references the AST class

			print('{indent}{attr_name}: {attr_value}'.format(
					indent=indent*(level+1),
					attr_name=a,
					attr_value=attr)
			)

			if isinstance(attr, supr):
				attr.describe(level=level+1)

			"""
			if hasattr(attr, 'children'):
				# if the attr is a Compound node
				for child in attr.children:
					print(child)
					child.describe(level=level+2)
			"""

			# I think this replaces the commented-out block above
			if a == 'children':
				for child in attr:
					child.describe(level=level+1)
					print(' ')


	def __repr__(self):
		return '<{class_name} Object>'.format(class_name=type(self).__name__)


def _is_iterable_of_ast(obj):
	# returns True if obj is an iterable with all elements instances of AST
	try:
		iter(obj)
		for o in obj:
			if not isinstance(o, AST):
				return False
		return True
	except TypeError:
		return False

class BinaryOp(AST):

	def __init__(self, left, op, right):
		self.left = left
		self.op = op
		self.right = right


class UnaryOp(AST):

	def __init__(self, op, expr):
		self.op = op
		self.expr = expr


class Num(AST):

	def __init__(self, token):
		self.token = token
		self.value = self.token.value


class Function(AST):

	def __init__(self, token, expr):
		self.token = token
		self.value = self.token.value
		self.expr = expr


class Param(AST):

	def __init__(self, token):
		self.token = token
		self.value = self.token.value


class Compound(AST):

	def __init__(self):
		self.children = list()


class Var(AST):

	def __init__(self, token):
		self.token = token
		self.value = self.token.value


class PeriodVar(AST):

	def __init__(self, token, period):
		self.token = token
		self.value = self.token.value
		self.period = period


class VarAssignment(AST):

	def __init__(self, left, op, right):
		self.left = left
		self.op = op
		self.right = right


class VarDeclaration(AST):

	def __init__(self, var_node, vtype):
		self.var_node = var_node
		self.vtype = vtype


class Tag(AST):

	def __init__(self):
		self.children = list()


class TagPair(AST):

	def __init__(self, key, value):
		self.key = key
		self.value = value


class ModelExpression(AST):

	def __init__(self, left, right, tag=None):
		self.left = left
		self.right = right
		self._tag = tag

	@property
	def tag(self):
		return self._tag

	@tag.setter
	def tag(self, value):
		self._tag = value


class Model(AST):

	def __init__(self):
		self.children = list()


class ModelBlock(AST):

	def __init__(self, parameters, model):
		self.parameters = parameters # (potentiall empty) list of Param objects
		self.model = model


class ModFile(AST):

	def __init__(self, declaration, assignment, model):
		self.declaration = declaration
		self.assignment = assignment
		self.model = model




